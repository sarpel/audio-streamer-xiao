#include "../config.h"
#include "web_server.h"
#include "config_manager_v2.h"
#include "network_manager.h"
#include "tcp_streamer.h"
#include "udp_streamer.h"
#include "buffer_manager.h"
#include "i2s_handler.h"
#include "ota_handler.h"
#include "performance_monitor.h"
#include "esp_log.h"
#include "esp_system.h"
#include "esp_chip_info.h"
#include "esp_timer.h"
#include "esp_mac.h"
#include "esp_ota_ops.h"
#include "esp_app_format.h"
#include "esp_wifi.h"
#include "cJSON.h"
#include "mbedtls/base64.h"
#include <string.h>
#include <errno.h>

static const char *TAG = "WEB_SERVER";
static httpd_handle_t server = NULL;

// Helper function to add CORS headers to responses
void web_server_add_cors_headers(httpd_req_t *req)
{
    httpd_resp_set_hdr(req, "Access-Control-Allow-Origin", "*");
    httpd_resp_set_hdr(req, "Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
    httpd_resp_set_hdr(req, "Access-Control-Allow-Headers", "Content-Type, Authorization");
    httpd_resp_set_hdr(req, "Access-Control-Max-Age", "86400");
}

// OPTIONS handler for CORS preflight requests
static esp_err_t options_handler(httpd_req_t *req)
{
    web_server_add_cors_headers(req);
    httpd_resp_set_status(req, "204 No Content");
    httpd_resp_send(req, NULL, 0);
    return ESP_OK;
}

// Endpoint configuration structure for simplified registration
typedef struct
{
    const char *uri;
    httpd_method_t method;
    esp_err_t (*handler)(httpd_req_t *);
} endpoint_config_t;

// Helper function to register multiple endpoints
static void register_endpoints(httpd_handle_t server, const endpoint_config_t *endpoints, size_t count)
{
    for (size_t i = 0; i < count; i++)
    {
        httpd_uri_t uri = {
            .uri = endpoints[i].uri,
            .method = endpoints[i].method,
            .handler = endpoints[i].handler,
            .user_ctx = NULL,
            .is_websocket = false,
            .handle_ws_control_frames = false,
            .supported_subprotocol = NULL};

        esp_err_t ret = httpd_register_uri_handler(server, &uri);
        if (ret != ESP_OK)
        {
            ESP_LOGE(TAG, "Failed to register %s %s: %s",
                     (endpoints[i].method == HTTP_GET) ? "GET" : "POST",
                     endpoints[i].uri,
                     esp_err_to_name(ret));
        }
    }
}

// Authentication functions
esp_err_t web_server_send_auth_required(httpd_req_t *req)
{
    // Add CORS headers first (critical for browser auth prompts to work)
    web_server_add_cors_headers(req);

    httpd_resp_set_status(req, "401 Unauthorized");
    httpd_resp_set_type(req, "application/json");
    httpd_resp_set_hdr(req, "WWW-Authenticate", "Basic realm=\"Audio Streamer\"");

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "error");
    cJSON_AddStringToObject(response, "message", "Authentication required");

    char *json_str = cJSON_Print(response);
    httpd_resp_sendstr(req, json_str);

    free(json_str);
    cJSON_Delete(response);
    return ESP_FAIL;
}

// Internal wrapper for backward compatibility
static esp_err_t send_auth_required(httpd_req_t *req)
{
    return web_server_send_auth_required(req);
}

bool web_server_check_auth(httpd_req_t *req)
{
    // Get stored credentials from unified configuration
    char username[32];
    char password[64];

    if (!config_manager_v2_get_field(CONFIG_FIELD_AUTH_USERNAME, username, sizeof(username)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_AUTH_PASSWORD, password, sizeof(password)))
    {
        ESP_LOGW(TAG, "Failed to get auth config");
        return false;
    }

    // Get Authorization header
    char auth_header[256];
    esp_err_t err = httpd_req_get_hdr_value_str(req, "Authorization", auth_header, sizeof(auth_header));
    if (err != ESP_OK)
    {
        ESP_LOGD(TAG, "No Authorization header");
        return false;
    }

    // Check for "Basic " prefix
    if (strncmp(auth_header, "Basic ", 6) != 0)
    {
        ESP_LOGW(TAG, "Invalid Authorization header format");
        return false;
    }

    // Decode base64
    unsigned char decoded[128];
    size_t decoded_len;
    int ret = mbedtls_base64_decode(decoded, sizeof(decoded), &decoded_len,
                                    (const unsigned char *)(auth_header + 6),
                                    strlen(auth_header + 6));
    if (ret != 0)
    {
        ESP_LOGW(TAG, "Failed to decode base64 auth: %d", ret);
        return false;
    }

    decoded[decoded_len] = '\0';

    // Split username:password
    char *colon = strchr((char *)decoded, ':');
    if (!colon)
    {
        ESP_LOGW(TAG, "Invalid auth format (no colon)");
        return false;
    }

    *colon = '\0';
    const char *req_username = (const char *)decoded;
    const char *req_password = colon + 1;

    // Compare credentials
    bool valid = (strcmp(req_username, username) == 0 && strcmp(req_password, password) == 0);

    if (!valid)
    {
        ESP_LOGW(TAG, "Invalid credentials");
    }

    return valid;
}

// Internal wrapper for backward compatibility
static bool check_basic_auth(httpd_req_t *req)
{
    return web_server_check_auth(req);
} // Helper to send 400 Bad Request (if not defined)
#ifndef httpd_resp_send_400
static inline esp_err_t httpd_resp_send_400(httpd_req_t *r)
{
    return httpd_resp_send_err(r, HTTPD_400_BAD_REQUEST, "Bad Request");
}
#endif

// Helper function to safely receive request body with bounds checking
static esp_err_t safe_httpd_req_recv(httpd_req_t *req, char *buf, size_t buf_size, size_t *received_len)
{
    if (!req || !buf || buf_size == 0)
    {
        ESP_LOGE(TAG, "Invalid parameters for safe_httpd_req_recv");
        return ESP_FAIL;
    }

    // Check content length
    size_t content_len = req->content_len;
    if (content_len >= buf_size)
    {
        ESP_LOGE(TAG, "Request too large: %zu bytes (buffer size: %zu)", content_len, buf_size);
        httpd_resp_send_err(req, HTTPD_400_BAD_REQUEST, "Request payload too large");
        return ESP_FAIL;
    }

    // Receive data
    int ret = httpd_req_recv(req, buf, buf_size - 1);
    if (ret <= 0)
    {
        ESP_LOGE(TAG, "Failed to receive request: ret=%d, errno=%d", ret, errno);
        if (ret == HTTPD_SOCK_ERR_TIMEOUT)
        {
            httpd_resp_send_408(req);
        }
        else
        {
            httpd_resp_send_500(req);
        }
        return ESP_FAIL;
    }

    // Validate received length
    if (ret >= (int)buf_size)
    {
        ESP_LOGE(TAG, "Buffer overflow prevented: received %d bytes, buffer size %zu", ret, buf_size);
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    buf[ret] = '\0';
    if (received_len)
    {
        *received_len = ret;
    }

    return ESP_OK;
}

// Helper function to send JSON response
esp_err_t web_server_send_json_response(httpd_req_t *req, cJSON *json, int status_code)
{
    char *response = cJSON_Print(json);
    if (!response)
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    web_server_add_cors_headers(req);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_set_status(req, status_code == 200 ? HTTPD_200 : status_code == 400 ? HTTPD_400
                                                            : status_code == 500   ? HTTPD_500
                                                                                   : HTTPD_200);
    httpd_resp_sendstr(req, response);

    free(response);
    return ESP_OK;
}

// Internal wrapper for backward compatibility
static esp_err_t send_json_response(httpd_req_t *req, cJSON *json, int status_code)
{
    return web_server_send_json_response(req, json, status_code);
}

// GET /api/config/wifi - Get WiFi configuration
static esp_err_t api_get_wifi_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    // Get WiFi configuration from unified config
    char ssid[32], password[64], static_ip[16], gateway[16], subnet[16];
    char dns_primary[16], dns_secondary[16];
    char use_static_ip_str[8];

    if (!config_manager_v2_get_field(CONFIG_FIELD_WIFI_SSID, ssid, sizeof(ssid)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_PASSWORD, password, sizeof(password)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_USE_STATIC_IP, use_static_ip_str, sizeof(use_static_ip_str)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_STATIC_IP, static_ip, sizeof(static_ip)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_GATEWAY, gateway, sizeof(gateway)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_SUBNET, subnet, sizeof(subnet)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_DNS_PRIMARY, dns_primary, sizeof(dns_primary)) ||
        !config_manager_v2_get_field(CONFIG_FIELD_WIFI_DNS_SECONDARY, dns_secondary, sizeof(dns_secondary)))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "ssid", ssid);
    cJSON_AddStringToObject(root, "password", "********"); // Don't expose password
    cJSON_AddBoolToObject(root, "use_static_ip", (strcmp(use_static_ip_str, "1") == 0));
    cJSON_AddStringToObject(root, "static_ip", static_ip);
    cJSON_AddStringToObject(root, "gateway", gateway);
    cJSON_AddStringToObject(root, "subnet", subnet);
    cJSON_AddStringToObject(root, "dns_primary", dns_primary);
    cJSON_AddStringToObject(root, "dns_secondary", dns_secondary);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/wifi - Update WiFi configuration
static esp_err_t api_post_wifi_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    wifi_config_data_t wifi;
    config_manager_get_wifi(&wifi); // Get current config

    // Update fields if present
    cJSON *ssid = cJSON_GetObjectItem(root, "ssid");
    if (ssid && cJSON_IsString(ssid))
    {
        strncpy(wifi.ssid, ssid->valuestring, sizeof(wifi.ssid) - 1);
    }

    cJSON *password = cJSON_GetObjectItem(root, "password");
    if (password && cJSON_IsString(password) && strcmp(password->valuestring, "********") != 0)
    {
        strncpy(wifi.password, password->valuestring, sizeof(wifi.password) - 1);
    }

    cJSON *use_static = cJSON_GetObjectItem(root, "use_static_ip");
    if (use_static && cJSON_IsBool(use_static))
    {
        wifi.use_static_ip = cJSON_IsTrue(use_static);
    }

    cJSON *static_ip = cJSON_GetObjectItem(root, "static_ip");
    if (static_ip && cJSON_IsString(static_ip))
    {
        strncpy(wifi.static_ip, static_ip->valuestring, sizeof(wifi.static_ip) - 1);
    }

    cJSON *gateway = cJSON_GetObjectItem(root, "gateway");
    if (gateway && cJSON_IsString(gateway))
    {
        strncpy(wifi.gateway, gateway->valuestring, sizeof(wifi.gateway) - 1);
    }

    cJSON *subnet = cJSON_GetObjectItem(root, "subnet");
    if (subnet && cJSON_IsString(subnet))
    {
        strncpy(wifi.subnet, subnet->valuestring, sizeof(wifi.subnet) - 1);
    }

    cJSON *dns_primary = cJSON_GetObjectItem(root, "dns_primary");
    if (dns_primary && cJSON_IsString(dns_primary))
    {
        strncpy(wifi.dns_primary, dns_primary->valuestring, sizeof(wifi.dns_primary) - 1);
    }

    cJSON *dns_secondary = cJSON_GetObjectItem(root, "dns_secondary");
    if (dns_secondary && cJSON_IsString(dns_secondary))
    {
        strncpy(wifi.dns_secondary, dns_secondary->valuestring, sizeof(wifi.dns_secondary) - 1);
    }

    config_manager_set_wifi(&wifi);
    config_manager_save();
    cJSON_Delete(root);

    // Send response
    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "WiFi configuration saved. Restart required.");
    cJSON_AddBoolToObject(response, "restart_required", true);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/tcp - Get TCP configuration
static esp_err_t api_get_tcp_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    tcp_config_data_t tcp;
    if (!config_manager_get_tcp(&tcp))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddStringToObject(root, "server_ip", tcp.server_ip);
    cJSON_AddNumberToObject(root, "server_port", tcp.server_port);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/tcp - Update TCP configuration
static esp_err_t api_post_tcp_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[256];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    tcp_config_data_t tcp;
    config_manager_get_tcp(&tcp);

    cJSON *server_ip = cJSON_GetObjectItem(root, "server_ip");
    if (server_ip && cJSON_IsString(server_ip))
    {
        strncpy(tcp.server_ip, server_ip->valuestring, sizeof(tcp.server_ip) - 1);
    }

    cJSON *server_port = cJSON_GetObjectItem(root, "server_port");
    if (server_port && cJSON_IsNumber(server_port))
    {
        tcp.server_port = server_port->valueint;
    }

    config_manager_set_tcp(&tcp);
    config_manager_save();
    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "TCP configuration saved. Restart required.");
    cJSON_AddBoolToObject(response, "restart_required", true);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/system/status - Get system status
static esp_err_t api_get_status_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *root = cJSON_CreateObject();

    // Uptime
    cJSON_AddNumberToObject(root, "uptime_sec", esp_timer_get_time() / 1000000);

    // WiFi status
    cJSON *wifi = cJSON_CreateObject();
    cJSON_AddBoolToObject(wifi, "connected", network_manager_is_connected());
    if (network_manager_is_connected())
    {
        // Get the ACTUAL connected SSID from WiFi stack, not from NVS config
        wifi_ap_record_t ap_info;
        if (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK)
        {
            cJSON_AddStringToObject(wifi, "ssid", (char *)ap_info.ssid);
            cJSON_AddNumberToObject(wifi, "rssi", ap_info.rssi);
        }
        else
        {
            // Fallback to config if WiFi stack query fails
            wifi_config_data_t wifi_cfg;
            config_manager_get_wifi(&wifi_cfg);
            cJSON_AddStringToObject(wifi, "ssid", wifi_cfg.ssid);
        }
    }
    else
    {
        cJSON_AddStringToObject(wifi, "ssid", "N/A");
    }
    cJSON_AddItemToObject(root, "wifi", wifi);

    // TCP status
    cJSON *tcp = cJSON_CreateObject();
    cJSON_AddBoolToObject(tcp, "connected", tcp_streamer_is_connected());
    tcp_config_data_t tcp_cfg;
    config_manager_get_tcp(&tcp_cfg);
    char server_str[32];
    snprintf(server_str, sizeof(server_str), "%s:%d", tcp_cfg.server_ip, tcp_cfg.server_port);
    cJSON_AddStringToObject(tcp, "server", server_str);

    uint64_t bytes_sent;
    uint32_t reconnects;
    tcp_streamer_get_stats(&bytes_sent, &reconnects);
    cJSON_AddNumberToObject(tcp, "bytes_sent", bytes_sent);
    cJSON_AddNumberToObject(tcp, "reconnects", reconnects);
    cJSON_AddItemToObject(root, "tcp", tcp);

    // Audio status
    cJSON *audio = cJSON_CreateObject();
    i2s_config_data_t i2s_cfg;
    config_manager_get_i2s(&i2s_cfg);
    cJSON_AddNumberToObject(audio, "sample_rate", i2s_cfg.sample_rate);
    cJSON_AddItemToObject(root, "audio", audio);

    // Buffer status
    cJSON *buffer = cJSON_CreateObject();
    buffer_config_data_t buf_cfg;
    config_manager_get_buffer(&buf_cfg);
    cJSON_AddNumberToObject(buffer, "size_kb", buf_cfg.ring_buffer_size / 1024);
    cJSON_AddNumberToObject(buffer, "usage_percent", buffer_manager_usage_percent());
    cJSON_AddItemToObject(root, "buffer", buffer);

    // Memory status
    cJSON *memory = cJSON_CreateObject();
    cJSON_AddNumberToObject(memory, "free_heap", esp_get_free_heap_size());
    cJSON_AddNumberToObject(memory, "min_free_heap", esp_get_minimum_free_heap_size());
    cJSON_AddItemToObject(root, "memory", memory);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// GET /api/system/info - Get device info
static esp_err_t api_get_info_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *root = cJSON_CreateObject();

    esp_chip_info_t chip_info;
    esp_chip_info(&chip_info);

    cJSON_AddStringToObject(root, "chip_model", "ESP32-S3");
    cJSON_AddNumberToObject(root, "cores", chip_info.cores);
    cJSON_AddNumberToObject(root, "revision", chip_info.revision);
    cJSON_AddStringToObject(root, "idf_version", esp_get_idf_version());

    uint8_t mac[6];
    esp_efuse_mac_get_default(mac);
    char mac_str[18];
    snprintf(mac_str, sizeof(mac_str), "%02X:%02X:%02X:%02X:%02X:%02X",
             mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    cJSON_AddStringToObject(root, "mac_address", mac_str);

    cJSON_AddStringToObject(root, "firmware_version", "1.0.0");

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/system/restart - Restart device
static esp_err_t api_post_restart_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Device will restart in 2 seconds");

    send_json_response(req, response, 200);
    cJSON_Delete(response);

    // Schedule restart
    vTaskDelay(pdMS_TO_TICKS(2000));
    esp_restart();

    return ESP_OK;
}

// POST /api/system/factory-reset - Factory reset
static esp_err_t api_post_factory_reset_handler(httpd_req_t *req)
{
    // Check authentication
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    ESP_LOGI(TAG, "Factory reset requested");

    if (!config_manager_reset_to_factory())
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to reset configuration");

        send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ESP_FAIL;
    }

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Factory reset complete. Device will restart.");

    send_json_response(req, response, 200);
    cJSON_Delete(response);

    vTaskDelay(pdMS_TO_TICKS(2000));
    esp_restart();

    return ESP_OK;
}

// GET /api/config/audio - Get I2S audio configuration
static esp_err_t api_get_audio_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    i2s_config_data_t i2s;
    if (!config_manager_get_i2s(&i2s))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "sample_rate", i2s.sample_rate);
    cJSON_AddNumberToObject(root, "bits_per_sample", i2s.bits_per_sample);
    cJSON_AddNumberToObject(root, "channels", i2s.channels);
    cJSON_AddNumberToObject(root, "bck_pin", i2s.bck_pin);
    cJSON_AddNumberToObject(root, "ws_pin", i2s.ws_pin);
    cJSON_AddNumberToObject(root, "data_in_pin", i2s.data_in_pin);

    // Calculate data rate
    uint32_t data_rate_bps = i2s.sample_rate * i2s.channels * (i2s.bits_per_sample / 8);
    cJSON_AddNumberToObject(root, "data_rate_bps", data_rate_bps);
    cJSON_AddNumberToObject(root, "data_rate_kbps", data_rate_bps / 1024.0);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/audio - Update I2S audio configuration
static esp_err_t api_post_audio_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    i2s_config_data_t i2s;
    config_manager_get_i2s(&i2s);

    bool changed = false;

    // GPIO pin changes require restart
    cJSON *bck_pin = cJSON_GetObjectItem(root, "bck_pin");
    if (bck_pin && cJSON_IsNumber(bck_pin))
    {
        uint8_t new_pin = bck_pin->valueint;
        if (new_pin != i2s.bck_pin)
        {
            i2s.bck_pin = new_pin;
            changed = true;
        }
    }

    cJSON *ws_pin = cJSON_GetObjectItem(root, "ws_pin");
    if (ws_pin && cJSON_IsNumber(ws_pin))
    {
        uint8_t new_pin = ws_pin->valueint;
        if (new_pin != i2s.ws_pin)
        {
            i2s.ws_pin = new_pin;
            changed = true;
        }
    }

    cJSON *data_in_pin = cJSON_GetObjectItem(root, "data_in_pin");
    if (data_in_pin && cJSON_IsNumber(data_in_pin))
    {
        uint8_t new_pin = data_in_pin->valueint;
        if (new_pin != i2s.data_in_pin)
        {
            i2s.data_in_pin = new_pin;
            changed = true;
        }
    }

    if (changed)
    {
        config_manager_set_i2s(&i2s);
        config_manager_save();
    }

    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    if (changed)
    {
        cJSON_AddStringToObject(response, "message", "Audio GPIO configuration saved. Restart required to apply changes.");
        cJSON_AddBoolToObject(response, "restart_required", true);
    }
    else
    {
        cJSON_AddStringToObject(response, "message", "No changes detected.");
        cJSON_AddBoolToObject(response, "restart_required", false);
    }

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/buffer - Get buffer configuration
static esp_err_t api_get_buffer_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    buffer_config_data_t buffer;
    if (!config_manager_get_buffer(&buffer))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "ring_buffer_size", buffer.ring_buffer_size);
    cJSON_AddNumberToObject(root, "dma_buf_count", buffer.dma_buf_count);
    cJSON_AddNumberToObject(root, "dma_buf_len", buffer.dma_buf_len);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/buffer - Update buffer configuration
static esp_err_t api_post_buffer_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    buffer_config_data_t buffer;
    config_manager_get_buffer(&buffer);

    cJSON *ring_buffer_size = cJSON_GetObjectItem(root, "ring_buffer_size");
    if (ring_buffer_size && cJSON_IsNumber(ring_buffer_size))
    {
        buffer.ring_buffer_size = ring_buffer_size->valueint;
    }

    cJSON *dma_buf_count = cJSON_GetObjectItem(root, "dma_buf_count");
    if (dma_buf_count && cJSON_IsNumber(dma_buf_count))
    {
        buffer.dma_buf_count = dma_buf_count->valueint;
    }

    cJSON *dma_buf_len = cJSON_GetObjectItem(root, "dma_buf_len");
    if (dma_buf_len && cJSON_IsNumber(dma_buf_len))
    {
        buffer.dma_buf_len = dma_buf_len->valueint;
    }

    config_manager_set_buffer(&buffer);
    config_manager_save();
    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Buffer configuration saved. Restart required.");
    cJSON_AddBoolToObject(response, "restart_required", true);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/tasks - Get task configuration
static esp_err_t api_get_tasks_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    task_config_data_t tasks;
    if (!config_manager_get_tasks(&tasks))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "i2s_reader_priority", tasks.i2s_reader_priority);
    cJSON_AddNumberToObject(root, "tcp_sender_priority", tasks.tcp_sender_priority);
    cJSON_AddNumberToObject(root, "watchdog_priority", tasks.watchdog_priority);
    cJSON_AddNumberToObject(root, "web_server_priority", tasks.web_server_priority);
    cJSON_AddNumberToObject(root, "i2s_reader_core", tasks.i2s_reader_core);
    cJSON_AddNumberToObject(root, "tcp_sender_core", tasks.tcp_sender_core);
    cJSON_AddNumberToObject(root, "watchdog_core", tasks.watchdog_core);
    cJSON_AddNumberToObject(root, "web_server_core", tasks.web_server_core);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/tasks - Update task configuration
static esp_err_t api_post_tasks_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    task_config_data_t tasks;
    config_manager_get_tasks(&tasks);

    cJSON *i2s_reader_priority = cJSON_GetObjectItem(root, "i2s_reader_priority");
    if (i2s_reader_priority && cJSON_IsNumber(i2s_reader_priority))
    {
        tasks.i2s_reader_priority = i2s_reader_priority->valueint;
    }

    cJSON *tcp_sender_priority = cJSON_GetObjectItem(root, "tcp_sender_priority");
    if (tcp_sender_priority && cJSON_IsNumber(tcp_sender_priority))
    {
        tasks.tcp_sender_priority = tcp_sender_priority->valueint;
    }

    cJSON *watchdog_priority = cJSON_GetObjectItem(root, "watchdog_priority");
    if (watchdog_priority && cJSON_IsNumber(watchdog_priority))
    {
        tasks.watchdog_priority = watchdog_priority->valueint;
    }

    cJSON *web_server_priority = cJSON_GetObjectItem(root, "web_server_priority");
    if (web_server_priority && cJSON_IsNumber(web_server_priority))
    {
        tasks.web_server_priority = web_server_priority->valueint;
    }

    cJSON *i2s_reader_core = cJSON_GetObjectItem(root, "i2s_reader_core");
    if (i2s_reader_core && cJSON_IsNumber(i2s_reader_core))
    {
        tasks.i2s_reader_core = i2s_reader_core->valueint;
    }

    cJSON *tcp_sender_core = cJSON_GetObjectItem(root, "tcp_sender_core");
    if (tcp_sender_core && cJSON_IsNumber(tcp_sender_core))
    {
        tasks.tcp_sender_core = tcp_sender_core->valueint;
    }

    cJSON *watchdog_core = cJSON_GetObjectItem(root, "watchdog_core");
    if (watchdog_core && cJSON_IsNumber(watchdog_core))
    {
        tasks.watchdog_core = watchdog_core->valueint;
    }

    cJSON *web_server_core = cJSON_GetObjectItem(root, "web_server_core");
    if (web_server_core && cJSON_IsNumber(web_server_core))
    {
        tasks.web_server_core = web_server_core->valueint;
    }

    config_manager_set_tasks(&tasks);
    config_manager_save();
    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Task configuration saved. Restart required.");
    cJSON_AddBoolToObject(response, "restart_required", true);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/error - Get error handling configuration
static esp_err_t api_get_error_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    error_config_data_t error;
    if (!config_manager_get_error(&error))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "max_reconnect_attempts", error.max_reconnect_attempts);
    cJSON_AddNumberToObject(root, "reconnect_backoff_ms", error.reconnect_backoff_ms);
    cJSON_AddNumberToObject(root, "max_reconnect_backoff_ms", error.max_reconnect_backoff_ms);
    cJSON_AddNumberToObject(root, "max_i2s_failures", error.max_i2s_failures);
    cJSON_AddNumberToObject(root, "max_buffer_overflows", error.max_buffer_overflows);
    cJSON_AddNumberToObject(root, "watchdog_timeout_sec", error.watchdog_timeout_sec);
    cJSON_AddNumberToObject(root, "ntp_resync_interval_sec", error.ntp_resync_interval_sec);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/error - Update error handling configuration
static esp_err_t api_post_error_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    error_config_data_t error;
    config_manager_get_error(&error);

    cJSON *max_reconnect_attempts = cJSON_GetObjectItem(root, "max_reconnect_attempts");
    if (max_reconnect_attempts && cJSON_IsNumber(max_reconnect_attempts))
    {
        error.max_reconnect_attempts = max_reconnect_attempts->valueint;
    }

    cJSON *reconnect_backoff_ms = cJSON_GetObjectItem(root, "reconnect_backoff_ms");
    if (reconnect_backoff_ms && cJSON_IsNumber(reconnect_backoff_ms))
    {
        error.reconnect_backoff_ms = reconnect_backoff_ms->valueint;
    }

    cJSON *max_reconnect_backoff_ms = cJSON_GetObjectItem(root, "max_reconnect_backoff_ms");
    if (max_reconnect_backoff_ms && cJSON_IsNumber(max_reconnect_backoff_ms))
    {
        error.max_reconnect_backoff_ms = max_reconnect_backoff_ms->valueint;
    }

    cJSON *max_i2s_failures = cJSON_GetObjectItem(root, "max_i2s_failures");
    if (max_i2s_failures && cJSON_IsNumber(max_i2s_failures))
    {
        error.max_i2s_failures = max_i2s_failures->valueint;
    }

    cJSON *max_buffer_overflows = cJSON_GetObjectItem(root, "max_buffer_overflows");
    if (max_buffer_overflows && cJSON_IsNumber(max_buffer_overflows))
    {
        error.max_buffer_overflows = max_buffer_overflows->valueint;
    }

    cJSON *watchdog_timeout_sec = cJSON_GetObjectItem(root, "watchdog_timeout_sec");
    if (watchdog_timeout_sec && cJSON_IsNumber(watchdog_timeout_sec))
    {
        error.watchdog_timeout_sec = watchdog_timeout_sec->valueint;
    }

    cJSON *ntp_resync_interval_sec = cJSON_GetObjectItem(root, "ntp_resync_interval_sec");
    if (ntp_resync_interval_sec && cJSON_IsNumber(ntp_resync_interval_sec))
    {
        error.ntp_resync_interval_sec = ntp_resync_interval_sec->valueint;
    }

    config_manager_set_error(&error);
    config_manager_save();
    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Error configuration saved. Restart required.");
    cJSON_AddBoolToObject(response, "restart_required", true);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/debug - Get debug configuration
static esp_err_t api_get_debug_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    debug_config_data_t debug;
    if (!config_manager_get_debug(&debug))
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    cJSON *root = cJSON_CreateObject();
    cJSON_AddBoolToObject(root, "debug_enabled", debug.debug_enabled);
    cJSON_AddBoolToObject(root, "stack_monitoring", debug.stack_monitoring);
    cJSON_AddBoolToObject(root, "auto_reboot", debug.auto_reboot);
    cJSON_AddBoolToObject(root, "i2s_reinit", debug.i2s_reinit);
    cJSON_AddBoolToObject(root, "buffer_drain", debug.buffer_drain);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/config/debug - Update debug configuration
static esp_err_t api_post_debug_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    debug_config_data_t debug;
    config_manager_get_debug(&debug);

    cJSON *debug_enabled = cJSON_GetObjectItem(root, "debug_enabled");
    if (debug_enabled && cJSON_IsBool(debug_enabled))
    {
        debug.debug_enabled = cJSON_IsTrue(debug_enabled);
    }

    cJSON *stack_monitoring = cJSON_GetObjectItem(root, "stack_monitoring");
    if (stack_monitoring && cJSON_IsBool(stack_monitoring))
    {
        debug.stack_monitoring = cJSON_IsTrue(stack_monitoring);
    }

    cJSON *auto_reboot = cJSON_GetObjectItem(root, "auto_reboot");
    if (auto_reboot && cJSON_IsBool(auto_reboot))
    {
        debug.auto_reboot = cJSON_IsTrue(auto_reboot);
    }

    cJSON *i2s_reinit = cJSON_GetObjectItem(root, "i2s_reinit");
    if (i2s_reinit && cJSON_IsBool(i2s_reinit))
    {
        debug.i2s_reinit = cJSON_IsTrue(i2s_reinit);
    }

    cJSON *buffer_drain = cJSON_GetObjectItem(root, "buffer_drain");
    if (buffer_drain && cJSON_IsBool(buffer_drain))
    {
        debug.buffer_drain = cJSON_IsTrue(buffer_drain);
    }

    config_manager_set_debug(&debug);
    config_manager_save();
    cJSON_Delete(root);

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Debug configuration saved.");
    cJSON_AddBoolToObject(response, "restart_required", false);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/config/all - Get all configuration in single call
static esp_err_t api_get_all_config_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *root = cJSON_CreateObject();

    // WiFi configuration
    wifi_config_data_t wifi;
    if (config_manager_get_wifi(&wifi))
    {
        cJSON *wifi_obj = cJSON_CreateObject();
        cJSON_AddStringToObject(wifi_obj, "ssid", wifi.ssid);
        cJSON_AddStringToObject(wifi_obj, "password", "********");
        cJSON_AddBoolToObject(wifi_obj, "use_static_ip", wifi.use_static_ip);
        cJSON_AddStringToObject(wifi_obj, "static_ip", wifi.static_ip);
        cJSON_AddStringToObject(wifi_obj, "gateway", wifi.gateway);
        cJSON_AddStringToObject(wifi_obj, "subnet", wifi.subnet);
        cJSON_AddStringToObject(wifi_obj, "dns_primary", wifi.dns_primary);
        cJSON_AddStringToObject(wifi_obj, "dns_secondary", wifi.dns_secondary);
        cJSON_AddItemToObject(root, "wifi", wifi_obj);
    }

    // TCP configuration
    tcp_config_data_t tcp;
    if (config_manager_get_tcp(&tcp))
    {
        cJSON *tcp_obj = cJSON_CreateObject();
        cJSON_AddStringToObject(tcp_obj, "server_ip", tcp.server_ip);
        cJSON_AddNumberToObject(tcp_obj, "server_port", tcp.server_port);
        cJSON_AddItemToObject(root, "tcp", tcp_obj);
    }

    // Audio configuration
    i2s_config_data_t i2s;
    if (config_manager_get_i2s(&i2s))
    {
        cJSON *audio_obj = cJSON_CreateObject();
        cJSON_AddNumberToObject(audio_obj, "sample_rate", i2s.sample_rate);
        cJSON_AddNumberToObject(audio_obj, "bits_per_sample", i2s.bits_per_sample);
        cJSON_AddNumberToObject(audio_obj, "channels", i2s.channels);
        cJSON_AddNumberToObject(audio_obj, "bck_pin", i2s.bck_pin);
        cJSON_AddNumberToObject(audio_obj, "ws_pin", i2s.ws_pin);
        cJSON_AddNumberToObject(audio_obj, "data_in_pin", i2s.data_in_pin);
        cJSON_AddItemToObject(root, "audio", audio_obj);
    }

    // Buffer configuration
    buffer_config_data_t buffer;
    if (config_manager_get_buffer(&buffer))
    {
        cJSON *buffer_obj = cJSON_CreateObject();
        cJSON_AddNumberToObject(buffer_obj, "ring_buffer_size", buffer.ring_buffer_size);
        cJSON_AddNumberToObject(buffer_obj, "dma_buf_count", buffer.dma_buf_count);
        cJSON_AddNumberToObject(buffer_obj, "dma_buf_len", buffer.dma_buf_len);
        cJSON_AddItemToObject(root, "buffer", buffer_obj);
    }

    // Task configuration
    task_config_data_t tasks;
    if (config_manager_get_tasks(&tasks))
    {
        cJSON *tasks_obj = cJSON_CreateObject();
        cJSON_AddNumberToObject(tasks_obj, "i2s_reader_priority", tasks.i2s_reader_priority);
        cJSON_AddNumberToObject(tasks_obj, "tcp_sender_priority", tasks.tcp_sender_priority);
        cJSON_AddNumberToObject(tasks_obj, "watchdog_priority", tasks.watchdog_priority);
        cJSON_AddNumberToObject(tasks_obj, "web_server_priority", tasks.web_server_priority);
        cJSON_AddNumberToObject(tasks_obj, "i2s_reader_core", tasks.i2s_reader_core);
        cJSON_AddNumberToObject(tasks_obj, "tcp_sender_core", tasks.tcp_sender_core);
        cJSON_AddNumberToObject(tasks_obj, "watchdog_core", tasks.watchdog_core);
        cJSON_AddNumberToObject(tasks_obj, "web_server_core", tasks.web_server_core);
        cJSON_AddItemToObject(root, "tasks", tasks_obj);
    }

    // Error configuration
    error_config_data_t error;
    if (config_manager_get_error(&error))
    {
        cJSON *error_obj = cJSON_CreateObject();
        cJSON_AddNumberToObject(error_obj, "max_reconnect_attempts", error.max_reconnect_attempts);
        cJSON_AddNumberToObject(error_obj, "reconnect_backoff_ms", error.reconnect_backoff_ms);
        cJSON_AddNumberToObject(error_obj, "max_reconnect_backoff_ms", error.max_reconnect_backoff_ms);
        cJSON_AddNumberToObject(error_obj, "max_i2s_failures", error.max_i2s_failures);
        cJSON_AddNumberToObject(error_obj, "max_buffer_overflows", error.max_buffer_overflows);
        cJSON_AddNumberToObject(error_obj, "watchdog_timeout_sec", error.watchdog_timeout_sec);
        cJSON_AddNumberToObject(error_obj, "ntp_resync_interval_sec", error.ntp_resync_interval_sec);
        cJSON_AddItemToObject(root, "error", error_obj);
    }

    // Debug configuration
    debug_config_data_t debug;
    if (config_manager_get_debug(&debug))
    {
        cJSON *debug_obj = cJSON_CreateObject();
        cJSON_AddBoolToObject(debug_obj, "debug_enabled", debug.debug_enabled);
        cJSON_AddBoolToObject(debug_obj, "stack_monitoring", debug.stack_monitoring);
        cJSON_AddBoolToObject(debug_obj, "auto_reboot", debug.auto_reboot);
        cJSON_AddBoolToObject(debug_obj, "i2s_reinit", debug.i2s_reinit);
        cJSON_AddBoolToObject(debug_obj, "buffer_drain", debug.buffer_drain);
        cJSON_AddItemToObject(root, "debug", debug_obj);
    }

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/system/save - Manually save configuration to NVS
static esp_err_t api_post_save_config_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *response = cJSON_CreateObject();

    if (config_manager_save())
    {
        cJSON_AddStringToObject(response, "status", "success");
        cJSON_AddStringToObject(response, "message", "Configuration saved to NVS successfully.");
        esp_err_t ret = send_json_response(req, response, 200);
        cJSON_Delete(response);
        return ret;
    }
    else
    {
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to save configuration to NVS.");
        esp_err_t ret = send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ret;
    }
}

// POST /api/system/load - Reload configuration from NVS
static esp_err_t api_post_load_config_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *response = cJSON_CreateObject();

    if (config_manager_load())
    {
        cJSON_AddStringToObject(response, "status", "success");
        cJSON_AddStringToObject(response, "message", "Configuration reloaded from NVS. Restart recommended to apply changes.");
        cJSON_AddBoolToObject(response, "restart_required", true);
        esp_err_t ret = send_json_response(req, response, 200);
        cJSON_Delete(response);
        return ret;
    }
    else
    {
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to reload configuration from NVS.");
        esp_err_t ret = send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ret;
    }
}

// GET /api/performance/metrics - Get detailed performance metrics
static esp_err_t api_get_performance_metrics_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *root = cJSON_CreateObject();

    // Network performance metrics
    cJSON *network = cJSON_CreateObject();

// TCP metrics
#if STREAMING_PROTOCOL == STREAMING_PROTOCOL_TCP || STREAMING_PROTOCOL == STREAMING_PROTOCOL_BOTH
    uint64_t tcp_bytes_sent = 0;
    uint32_t tcp_reconnects = 0;
    tcp_streamer_get_stats(&tcp_bytes_sent, &tcp_reconnects);

    cJSON *tcp_metrics = cJSON_CreateObject();
    cJSON_AddNumberToObject(tcp_metrics, "bytes_sent", tcp_bytes_sent);
    cJSON_AddNumberToObject(tcp_metrics, "reconnects", tcp_reconnects);
    cJSON_AddBoolToObject(tcp_metrics, "connected", tcp_streamer_is_connected());
    cJSON_AddItemToObject(network, "tcp", tcp_metrics);
#endif

// UDP metrics
#if STREAMING_PROTOCOL == STREAMING_PROTOCOL_UDP || STREAMING_PROTOCOL == STREAMING_PROTOCOL_BOTH
    uint64_t udp_bytes_sent = 0;
    uint32_t udp_packets_sent = 0, udp_lost_packets = 0;
    udp_streamer_get_stats(&udp_bytes_sent, &udp_packets_sent, &udp_lost_packets);

    cJSON *udp_metrics = cJSON_CreateObject();
    cJSON_AddNumberToObject(udp_metrics, "bytes_sent", udp_bytes_sent);
    cJSON_AddNumberToObject(udp_metrics, "packets_sent", udp_packets_sent);
    cJSON_AddNumberToObject(udp_metrics, "lost_packets", udp_lost_packets);
    cJSON_AddBoolToObject(udp_metrics, "connected", udp_streamer_is_connected());
    double packet_loss_rate = (udp_packets_sent > 0) ? (double)udp_lost_packets / udp_packets_sent * 100.0 : 0.0;
    cJSON_AddNumberToObject(udp_metrics, "packet_loss_rate", packet_loss_rate);
    cJSON_AddItemToObject(network, "udp", udp_metrics);
#endif

    cJSON_AddItemToObject(root, "network", network);

    // Buffer performance metrics
    cJSON *buffer = cJSON_CreateObject();
    cJSON_AddNumberToObject(buffer, "usage_percent", buffer_manager_usage_percent());
    cJSON_AddNumberToObject(buffer, "available_samples", buffer_manager_available());
    cJSON_AddNumberToObject(buffer, "free_space_samples", buffer_manager_free_space());
    cJSON_AddBoolToObject(buffer, "overflow_detected", buffer_manager_check_overflow());

#if ADAPTIVE_BUFFERING_ENABLED
    // Adaptive buffering metrics
    size_t current_buffer_size = 0;
    uint32_t resize_count = 0, last_resize_time = 0;
    buffer_manager_adaptive_get_stats(&current_buffer_size, &resize_count, &last_resize_time);

    cJSON *adaptive = cJSON_CreateObject();
    cJSON_AddNumberToObject(adaptive, "current_size_bytes", current_buffer_size);
    cJSON_AddNumberToObject(adaptive, "current_size_kb", current_buffer_size / 1024);
    cJSON_AddNumberToObject(adaptive, "resize_count", resize_count);
    cJSON_AddNumberToObject(adaptive, "last_resize_time_ms", last_resize_time);
    cJSON_AddBoolToObject(adaptive, "enabled", buffer_manager_adaptive_is_enabled());
    cJSON_AddItemToObject(buffer, "adaptive", adaptive);
#endif

    cJSON_AddItemToObject(root, "buffer", buffer);

    // Memory performance metrics
    cJSON *memory = cJSON_CreateObject();
    cJSON_AddNumberToObject(memory, "free_heap", esp_get_free_heap_size());
    cJSON_AddNumberToObject(memory, "min_free_heap", esp_get_minimum_free_heap_size());
    cJSON_AddNumberToObject(memory, "largest_free_block", heap_caps_get_largest_free_block(MALLOC_CAP_8BIT));

    // Memory fragmentation calculation
    size_t free_heap = esp_get_free_heap_size();
    size_t largest_block = heap_caps_get_largest_free_block(MALLOC_CAP_8BIT);
    double fragmentation = (largest_block > 0) ? (1.0 - (double)largest_block / free_heap) * 100.0 : 0.0;
    cJSON_AddNumberToObject(memory, "fragmentation_percent", fragmentation);

    cJSON_AddItemToObject(root, "memory", memory);

    // System performance metrics
    cJSON *system = cJSON_CreateObject();
    cJSON_AddNumberToObject(system, "uptime_sec", esp_timer_get_time() / 1000000);

    // WiFi performance
    if (network_manager_is_connected())
    {
        wifi_ap_record_t ap_info;
        if (esp_wifi_sta_get_ap_info(&ap_info) == ESP_OK)
        {
            cJSON *wifi_perf = cJSON_CreateObject();
            cJSON_AddNumberToObject(wifi_perf, "rssi", ap_info.rssi);
            cJSON_AddNumberToObject(wifi_perf, "channel", ap_info.primary);
            // Remove link_speed as it's not available in this ESP-IDF version
            // cJSON_AddNumberToObject(wifi_perf, "link_speed", ap_info.link_speed);
            cJSON_AddItemToObject(system, "wifi", wifi_perf);
        }
    }

#if configGENERATE_RUN_TIME_STATS
    // CPU usage metrics
    TaskStatus_t task_stats[20];
    UBaseType_t task_count = uxTaskGetNumberOfTasks();
    uint32_t total_runtime = 0;

    if (task_count <= 20)
    {
        task_count = uxTaskGetSystemState(task_stats, task_count, &total_runtime);

        cJSON *cpu_usage = cJSON_CreateArray();

        for (UBaseType_t i = 0; i < task_count; i++)
        {
            cJSON *task = cJSON_CreateObject();
            cJSON_AddStringToObject(task, "name", task_stats[i].pcTaskName);
            cJSON_AddNumberToObject(task, "priority", task_stats[i].uxCurrentPriority);
            cJSON_AddNumberToObject(task, "core_number", xTaskGetCoreID(task_stats[i].xHandle));

            uint32_t cpu_percent = 0;
            if (total_runtime > 0)
            {
                cpu_percent = (task_stats[i].ulRunTimeCounter * 100UL) / total_runtime;
            }
            cJSON_AddNumberToObject(task, "cpu_percent", cpu_percent);

            cJSON_AddItemToArray(cpu_usage, task);
        }

        cJSON_AddItemToObject(system, "cpu_usage", cpu_usage);
    }
#endif

    cJSON_AddItemToObject(root, "system", system);

    // Audio performance metrics
    cJSON *audio = cJSON_CreateObject();
    i2s_config_data_t i2s_cfg;
    config_manager_get_i2s(&i2s_cfg);

    cJSON_AddNumberToObject(audio, "sample_rate", i2s_cfg.sample_rate);
    cJSON_AddNumberToObject(audio, "bits_per_sample", i2s_cfg.bits_per_sample);
    cJSON_AddNumberToObject(audio, "channels", i2s_cfg.channels);

    // Calculate audio data rate
    uint32_t audio_data_rate = i2s_cfg.sample_rate * i2s_cfg.channels * (i2s_cfg.bits_per_sample / 8);
    cJSON_AddNumberToObject(audio, "data_rate_bps", audio_data_rate);
    cJSON_AddNumberToObject(audio, "data_rate_kbps", audio_data_rate / 1024.0);

    cJSON_AddItemToObject(root, "audio", audio);

    // Timestamp
    cJSON_AddNumberToObject(root, "timestamp_ms", esp_timer_get_time() / 1000);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// GET /api/monitoring/history - Get historical performance data
static esp_err_t api_get_monitoring_history_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    // Parse query parameters
    char query_str[256];
    uint32_t start_time = 0, end_time = 0;
    size_t max_entries = 100;

    if (httpd_req_get_url_query_str(req, query_str, sizeof(query_str)) == ESP_OK)
    {
        // Parse start_time
        char param[32];
        if (httpd_query_key_value(query_str, "start", param, sizeof(param)) == ESP_OK)
        {
            start_time = strtoul(param, NULL, 10);
        }

        // Parse end_time
        if (httpd_query_key_value(query_str, "end", param, sizeof(param)) == ESP_OK)
        {
            end_time = strtoul(param, NULL, 10);
        }

        // Parse limit
        if (httpd_query_key_value(query_str, "limit", param, sizeof(param)) == ESP_OK)
        {
            max_entries = strtoul(param, NULL, 10);
            if (max_entries > 500)
                max_entries = 500; // Cap at 500 entries
        }
    }

    performance_metrics_t *history = (performance_metrics_t *)malloc(max_entries * sizeof(performance_metrics_t));
    if (!history)
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    size_t count = performance_monitor_get_history(start_time, end_time, history, max_entries);

    // Create JSON response
    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "start_time_ms", start_time);
    cJSON_AddNumberToObject(root, "end_time_ms", end_time);
    cJSON_AddNumberToObject(root, "count", count);

    cJSON *data_array = cJSON_CreateArray();
    for (size_t i = 0; i < count; i++)
    {
        cJSON *entry = cJSON_CreateObject();
        cJSON_AddNumberToObject(entry, "timestamp_ms", history[i].timestamp_ms);

        // Network metrics
        cJSON *network = cJSON_CreateObject();
#if STREAMING_PROTOCOL == STREAMING_PROTOCOL_TCP || STREAMING_PROTOCOL == STREAMING_PROTOCOL_BOTH
        cJSON *tcp = cJSON_CreateObject();
        cJSON_AddNumberToObject(tcp, "bytes_sent", history[i].tcp_bytes_sent);
        cJSON_AddNumberToObject(tcp, "reconnects", history[i].tcp_reconnects);
        cJSON_AddBoolToObject(tcp, "connected", history[i].tcp_connected);
        cJSON_AddItemToObject(network, "tcp", tcp);
#endif

#if STREAMING_PROTOCOL == STREAMING_PROTOCOL_UDP || STREAMING_PROTOCOL == STREAMING_PROTOCOL_BOTH
        cJSON *udp = cJSON_CreateObject();
        cJSON_AddNumberToObject(udp, "bytes_sent", history[i].udp_bytes_sent);
        cJSON_AddNumberToObject(udp, "packets_sent", history[i].udp_packets_sent);
        cJSON_AddNumberToObject(udp, "lost_packets", history[i].udp_lost_packets);
        cJSON_AddNumberToObject(udp, "packet_loss_rate", history[i].udp_packet_loss_rate);
        cJSON_AddBoolToObject(udp, "connected", history[i].udp_connected);
        cJSON_AddItemToObject(network, "udp", udp);
#endif
        cJSON_AddItemToObject(entry, "network", network);

        // Buffer metrics
        cJSON *buffer = cJSON_CreateObject();
        cJSON_AddNumberToObject(buffer, "usage_percent", history[i].buffer_usage_percent);
        cJSON_AddNumberToObject(buffer, "available_samples", history[i].buffer_available_samples);
        cJSON_AddNumberToObject(buffer, "free_space_samples", history[i].buffer_free_space_samples);
        cJSON_AddBoolToObject(buffer, "overflow_detected", history[i].buffer_overflow_detected);
        cJSON_AddItemToObject(entry, "buffer", buffer);

        // Memory metrics
        cJSON *memory = cJSON_CreateObject();
        cJSON_AddNumberToObject(memory, "free_heap", history[i].free_heap);
        cJSON_AddNumberToObject(memory, "min_free_heap", history[i].min_free_heap);
        cJSON_AddNumberToObject(memory, "largest_free_block", history[i].largest_free_block);
        cJSON_AddNumberToObject(memory, "fragmentation_percent", history[i].fragmentation_percent);
        cJSON_AddItemToObject(entry, "memory", memory);

        // System metrics
        cJSON *system = cJSON_CreateObject();
        cJSON_AddNumberToObject(system, "uptime_sec", history[i].uptime_sec);
        cJSON_AddNumberToObject(system, "wifi_rssi", history[i].wifi_rssi);
        cJSON_AddNumberToObject(system, "wifi_channel", history[i].wifi_channel);
        cJSON_AddNumberToObject(system, "audio_data_rate_bps", history[i].audio_data_rate_bps);
        cJSON_AddItemToObject(entry, "system", system);

        cJSON_AddItemToArray(data_array, entry);
    }
    cJSON_AddItemToObject(root, "data", data_array);

    free(history);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// GET /api/monitoring/alerts - Get performance alerts
static esp_err_t api_get_monitoring_alerts_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    // Parse query parameters
    char query_str[256];
    alert_level_t min_level = ALERT_LEVEL_INFO;
    size_t max_entries = 50;

    if (httpd_req_get_url_query_str(req, query_str, sizeof(query_str)) == ESP_OK)
    {
        char param[32];

        // Parse level
        if (httpd_query_key_value(query_str, "level", param, sizeof(param)) == ESP_OK)
        {
            int level = atoi(param);
            if (level >= ALERT_LEVEL_INFO && level <= ALERT_LEVEL_CRITICAL)
            {
                min_level = (alert_level_t)level;
            }
        }

        // Parse limit
        if (httpd_query_key_value(query_str, "limit", param, sizeof(param)) == ESP_OK)
        {
            max_entries = strtoul(param, NULL, 10);
            if (max_entries > 100)
                max_entries = 100; // Cap at 100 entries
        }
    }

    performance_alert_t *alerts = (performance_alert_t *)malloc(max_entries * sizeof(performance_alert_t));
    if (!alerts)
    {
        httpd_resp_send_500(req);
        return ESP_FAIL;
    }

    size_t count = performance_monitor_get_alerts(alerts, max_entries, min_level);

    // Create JSON response
    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "count", count);
    cJSON_AddNumberToObject(root, "min_level", min_level);

    cJSON *alerts_array = cJSON_CreateArray();
    for (size_t i = 0; i < count; i++)
    {
        cJSON *alert = cJSON_CreateObject();
        cJSON_AddNumberToObject(alert, "timestamp_ms", alerts[i].timestamp_ms);
        cJSON_AddNumberToObject(alert, "level", alerts[i].level);
        cJSON_AddStringToObject(alert, "category", alerts[i].category);
        cJSON_AddStringToObject(alert, "message", alerts[i].message);
        cJSON_AddItemToArray(alerts_array, alert);
    }
    cJSON_AddItemToObject(root, "alerts", alerts_array);

    free(alerts);

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// DELETE /api/monitoring/alerts - Clear performance alerts
static esp_err_t api_delete_monitoring_alerts_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    performance_monitor_clear_alerts();

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Alerts cleared successfully");

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/monitoring/summary - Get performance summary
static esp_err_t api_get_monitoring_summary_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    // Parse duration parameter (default 60 minutes)
    char query_str[256];
    uint32_t duration_min = 60;

    if (httpd_req_get_url_query_str(req, query_str, sizeof(query_str)) == ESP_OK)
    {
        char param[32];
        if (httpd_query_key_value(query_str, "duration", param, sizeof(param)) == ESP_OK)
        {
            duration_min = strtoul(param, NULL, 10);
            if (duration_min > 1440)
                duration_min = 1440; // Cap at 24 hours
        }
    }

    uint32_t avg_buffer_usage = 0, max_buffer_usage = 0, total_drops = 0, uptime_percent = 0;
    performance_monitor_get_summary(duration_min, &avg_buffer_usage, &max_buffer_usage, &total_drops, &uptime_percent);

    // Get current metrics
    performance_metrics_t current;
    bool has_current = performance_monitor_get_latest(&current);

    cJSON *root = cJSON_CreateObject();
    cJSON_AddNumberToObject(root, "duration_min", duration_min);
    cJSON_AddNumberToObject(root, "avg_buffer_usage_percent", avg_buffer_usage);
    cJSON_AddNumberToObject(root, "max_buffer_usage_percent", max_buffer_usage);
    cJSON_AddNumberToObject(root, "total_drops", total_drops);
    cJSON_AddNumberToObject(root, "uptime_percent", uptime_percent);

    if (has_current)
    {
        cJSON *current_metrics = cJSON_CreateObject();
        cJSON_AddNumberToObject(current_metrics, "timestamp_ms", current.timestamp_ms);
        cJSON_AddNumberToObject(current_metrics, "buffer_usage_percent", current.buffer_usage_percent);
        cJSON_AddNumberToObject(current_metrics, "free_heap", current.free_heap);
        cJSON_AddNumberToObject(current_metrics, "fragmentation_percent", current.fragmentation_percent);
        cJSON_AddNumberToObject(current_metrics, "uptime_sec", current.uptime_sec);
        cJSON_AddItemToObject(root, "current", current_metrics);
    }

    esp_err_t ret = send_json_response(req, root, 200);
    cJSON_Delete(root);
    return ret;
}

// POST /api/monitoring/config - Configure monitoring settings
static esp_err_t api_post_monitoring_config_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[512];
    if (safe_httpd_req_recv(req, buf, sizeof(buf), NULL) != ESP_OK)
    {
        return ESP_FAIL;
    }

    cJSON *root = cJSON_Parse(buf);
    if (!root)
    {
        httpd_resp_send_400(req);
        return ESP_FAIL;
    }

    // Parse configuration
    cJSON *enabled = cJSON_GetObjectItem(root, "enabled");
    if (enabled && cJSON_IsBool(enabled))
    {
        performance_monitor_set_enabled(cJSON_IsTrue(enabled));
    }

    cJSON *interval = cJSON_GetObjectItem(root, "interval_ms");
    if (interval && cJSON_IsNumber(interval))
    {
        uint32_t interval_val = interval->valueint;
        if (interval_val >= 1000 && interval_val <= 300000) // 1 second to 5 minutes
        {
            performance_monitor_set_interval(interval_val);
        }
    }

    cJSON_Delete(root);

    // Get current configuration
    bool current_enabled = performance_monitor_is_enabled();
    uint32_t current_interval = performance_monitor_get_interval();

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Monitoring configuration updated");
    cJSON_AddBoolToObject(response, "enabled", current_enabled);
    cJSON_AddNumberToObject(response, "interval_ms", current_interval);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);
    return ret;
}

// GET /api/system/backup - Export configuration to JSON
static esp_err_t api_get_backup_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char json_buffer[4096];
    if (!config_manager_export_json(json_buffer, sizeof(json_buffer)))
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to export configuration");

        esp_err_t ret = send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ret;
    }

    // Set response headers for file download
    web_server_add_cors_headers(req);
    httpd_resp_set_type(req, "application/json");
    httpd_resp_set_hdr(req, "Content-Disposition", "attachment; filename=\"audio-streamer-config.json\"");

    // Get current timestamp for filename
    uint64_t timestamp = esp_timer_get_time() / 1000;
    char filename[64];
    snprintf(filename, sizeof(filename), "attachment; filename=\"audio-streamer-config-%llu.json\"", timestamp);
    httpd_resp_set_hdr(req, "Content-Disposition", filename);

    httpd_resp_sendstr(req, json_buffer);

    ESP_LOGI(TAG, "Configuration exported successfully (%zu bytes)", strlen(json_buffer));
    return ESP_OK;
}

// POST /api/system/restore - Import configuration from JSON
static esp_err_t api_post_restore_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    char buf[4096];
    size_t received_len = 0;

    if (safe_httpd_req_recv(req, buf, sizeof(buf), &received_len) != ESP_OK)
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to receive configuration data");

        esp_err_t ret = send_json_response(req, response, 400);
        cJSON_Delete(response);
        return ret;
    }

    // Parse overwrite parameter from query string
    char query_str[64];
    bool overwrite = false;
    if (httpd_req_get_url_query_str(req, query_str, sizeof(query_str)) == ESP_OK)
    {
        char param[16];
        if (httpd_query_key_value(query_str, "overwrite", param, sizeof(param)) == ESP_OK)
        {
            overwrite = (strcmp(param, "true") == 0);
        }
    }

    // Validate JSON before importing
    cJSON *test_json = cJSON_Parse(buf);
    if (!test_json)
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Invalid JSON format");

        esp_err_t ret = send_json_response(req, response, 400);
        cJSON_Delete(response);
        return ret;
    }
    cJSON_Delete(test_json);

    // Import configuration
    if (!config_manager_import_json(buf, overwrite))
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to import configuration");

        esp_err_t ret = send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ret;
    }

    // Validate imported configuration
    if (!config_manager_validate())
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Imported configuration validation failed");

        esp_err_t ret = send_json_response(req, response, 400);
        cJSON_Delete(response);
        return ret;
    }

    // Save imported configuration to NVS
    if (!config_manager_save())
    {
        cJSON *response = cJSON_CreateObject();
        cJSON_AddStringToObject(response, "status", "error");
        cJSON_AddStringToObject(response, "message", "Failed to save imported configuration");

        esp_err_t ret = send_json_response(req, response, 500);
        cJSON_Delete(response);
        return ret;
    }

    cJSON *response = cJSON_CreateObject();
    cJSON_AddStringToObject(response, "status", "success");
    cJSON_AddStringToObject(response, "message", "Configuration imported successfully. Restart required to apply changes.");
    cJSON_AddBoolToObject(response, "restart_required", true);
    cJSON_AddNumberToObject(response, "bytes_received", received_len);
    cJSON_AddBoolToObject(response, "overwrite", overwrite);

    esp_err_t ret = send_json_response(req, response, 200);
    cJSON_Delete(response);

    ESP_LOGI(TAG, "Configuration imported successfully (%zu bytes, overwrite: %s)",
             received_len, overwrite ? "true" : "false");
    return ret;
}

// GET /api/system/validate - Validate current configuration
static esp_err_t api_get_validate_handler(httpd_req_t *req)
{
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    cJSON *response = cJSON_CreateObject();

    if (config_manager_validate())
    {
        cJSON_AddStringToObject(response, "status", "valid");
        cJSON_AddStringToObject(response, "message", "Current configuration is valid");

        // Add configuration version info
        cJSON_AddNumberToObject(response, "version", config_manager_get_version());

        // Add configuration summary
        wifi_config_data_t wifi;
        if (config_manager_get_wifi(&wifi))
        {
            cJSON *wifi_info = cJSON_CreateObject();
            cJSON_AddStringToObject(wifi_info, "ssid", wifi.ssid);
            cJSON_AddBoolToObject(wifi_info, "static_ip", wifi.use_static_ip);
            cJSON_AddItemToObject(response, "wifi_summary", wifi_info);
        }

        tcp_config_data_t tcp;
        if (config_manager_get_tcp(&tcp))
        {
            char server_str[32];
            snprintf(server_str, sizeof(server_str), "%s:%d", tcp.server_ip, tcp.server_port);
            cJSON_AddStringToObject(response, "tcp_server", server_str);
        }

        esp_err_t ret = send_json_response(req, response, 200);
        cJSON_Delete(response);
        return ret;
    }
    else
    {
        cJSON_AddStringToObject(response, "status", "invalid");
        cJSON_AddStringToObject(response, "message", "Current configuration has validation errors");

        esp_err_t ret = send_json_response(req, response, 400);
        cJSON_Delete(response);
        return ret;
    }
}

// External symbols for embedded web files
// HTML files
extern const uint8_t index_html_start[] asm("_binary_index_html_start");
extern const uint8_t index_html_end[] asm("_binary_index_html_end");
extern const uint8_t config_html_start[] asm("_binary_config_html_start");
extern const uint8_t config_html_end[] asm("_binary_config_html_end");
extern const uint8_t monitor_html_start[] asm("_binary_monitor_html_start");
extern const uint8_t monitor_html_end[] asm("_binary_monitor_html_end");
extern const uint8_t ota_html_start[] asm("_binary_ota_html_start");
extern const uint8_t ota_html_end[] asm("_binary_ota_html_end");
extern const uint8_t logs_html_start[] asm("_binary_logs_html_start");
extern const uint8_t logs_html_end[] asm("_binary_logs_html_end");
extern const uint8_t network_html_start[] asm("_binary_network_html_start");
extern const uint8_t network_html_end[] asm("_binary_network_html_end");

// CSS files
extern const uint8_t style_css_start[] asm("_binary_style_css_start");
extern const uint8_t style_css_end[] asm("_binary_style_css_end");

// JS files
extern const uint8_t api_js_start[] asm("_binary_api_js_start");
extern const uint8_t api_js_end[] asm("_binary_api_js_end");
extern const uint8_t utils_js_start[] asm("_binary_utils_js_start");
extern const uint8_t utils_js_end[] asm("_binary_utils_js_end");
extern const uint8_t app_js_start[] asm("_binary_app_js_start");
extern const uint8_t app_js_end[] asm("_binary_app_js_end");
extern const uint8_t config_js_start[] asm("_binary_config_js_start");
extern const uint8_t config_js_end[] asm("_binary_config_js_end");
extern const uint8_t monitor_js_start[] asm("_binary_monitor_js_start");
extern const uint8_t monitor_js_end[] asm("_binary_monitor_js_end");
extern const uint8_t ota_js_start[] asm("_binary_ota_js_start");
extern const uint8_t ota_js_end[] asm("_binary_ota_js_end");
extern const uint8_t logs_js_start[] asm("_binary_logs_js_start");
extern const uint8_t logs_js_end[] asm("_binary_logs_js_end");
extern const uint8_t network_js_start[] asm("_binary_network_js_start");
extern const uint8_t network_js_end[] asm("_binary_network_js_end");

// Helper function to determine MIME type from file extension
static const char *get_mime_type(const char *path)
{
    const char *ext = strrchr(path, '.');
    if (!ext)
    {
        return "application/octet-stream";
    }

    if (strcmp(ext, ".html") == 0)
    {
        return "text/html";
    }
    else if (strcmp(ext, ".css") == 0)
    {
        return "text/css";
    }
    else if (strcmp(ext, ".js") == 0)
    {
        return "application/javascript";
    }
    else if (strcmp(ext, ".json") == 0)
    {
        return "application/json";
    }
    else if (strcmp(ext, ".png") == 0)
    {
        return "image/png";
    }
    else if (strcmp(ext, ".jpg") == 0 || strcmp(ext, ".jpeg") == 0)
    {
        return "image/jpeg";
    }
    else if (strcmp(ext, ".ico") == 0)
    {
        return "image/x-icon";
    }
    else if (strcmp(ext, ".svg") == 0)
    {
        return "image/svg+xml";
    }

    return "application/octet-stream";
}

// Generic file serving handler
static esp_err_t serve_embedded_file(httpd_req_t *req, const uint8_t *start, const uint8_t *end, const char *path)
{
    size_t file_size = end - start;
    const char *mime_type = get_mime_type(path);

    // Files embedded with TEXT mode have a null terminator that should not be sent
    // Check if the last byte is null and exclude it if so
    if (file_size > 0 && start[file_size - 1] == '\0')
    {
        file_size--;
    }

    ESP_LOGD(TAG, "Serving %s (%zu bytes, %s)", path, file_size, mime_type);

    web_server_add_cors_headers(req);
    httpd_resp_set_type(req, mime_type);
    httpd_resp_send(req, (const char *)start, file_size);

    return ESP_OK;
}

// Root handler - serves index.html
static esp_err_t root_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, index_html_start, index_html_end, "index.html");
}

// HTML file handlers
static esp_err_t config_html_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, config_html_start, config_html_end, "config.html");
}

static esp_err_t monitor_html_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, monitor_html_start, monitor_html_end, "monitor.html");
}

static esp_err_t ota_html_handler(httpd_req_t *req)
{
    // Require authentication for OTA page
    if (!check_basic_auth(req))
    {
        return send_auth_required(req);
    }

    return serve_embedded_file(req, ota_html_start, ota_html_end, "ota.html");
}

static esp_err_t logs_html_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, logs_html_start, logs_html_end, "logs.html");
}

static esp_err_t network_html_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, network_html_start, network_html_end, "network.html");
}

// CSS file handlers
static esp_err_t css_style_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, style_css_start, style_css_end, "style.css");
}

// JS file handlers
static esp_err_t js_api_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, api_js_start, api_js_end, "api.js");
}

static esp_err_t js_utils_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, utils_js_start, utils_js_end, "utils.js");
}

static esp_err_t js_app_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, app_js_start, app_js_end, "app.js");
}

static esp_err_t js_config_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, config_js_start, config_js_end, "config.js");
}

static esp_err_t js_monitor_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, monitor_js_start, monitor_js_end, "monitor.js");
}

static esp_err_t js_ota_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, ota_js_start, ota_js_end, "ota.js");
}

static esp_err_t js_logs_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, logs_js_start, logs_js_end, "logs.js");
}

static esp_err_t js_network_handler(httpd_req_t *req)
{
    return serve_embedded_file(req, network_js_start, network_js_end, "network.js");
}

// 404 handler
static esp_err_t notfound_handler(httpd_req_t *req, httpd_err_code_t err)
{
    httpd_resp_set_status(req, "404 Not Found");
    httpd_resp_set_type(req, "text/html");
    const char *html = "<!DOCTYPE html><html><head><title>404 Not Found</title></head>"
                       "<body><h1>404 Not Found</h1>"
                       "<p>The requested resource was not found on this server.</p>"
                       "<p><a href=\"/\">Return to Home</a></p>"
                       "</body></html>";
    httpd_resp_sendstr(req, html);
    return ESP_OK;
}

bool web_server_init(void)
{
    if (server != NULL)
    {
        ESP_LOGW(TAG, "Web server already running");
        return true;
    }

    httpd_config_t config = HTTPD_DEFAULT_CONFIG();
    config.server_port = 80;
    config.max_uri_handlers = 48; // Increased to accommodate all web UI endpoints + OTA + OPTIONS + 404
    config.max_open_sockets = 4;
    config.lru_purge_enable = true;
    config.stack_size = 8192;

    ESP_LOGI(TAG, "Starting web server on port %d", config.server_port);

    if (httpd_start(&server, &config) != ESP_OK)
    {
        ESP_LOGE(TAG, "Failed to start web server");
        return false;
    }

    // Define all endpoints in a compact array
    const endpoint_config_t endpoints[] = {
        // Root
        {"/", HTTP_GET, root_handler},

        // HTML pages
        {"/config.html", HTTP_GET, config_html_handler},
        {"/monitor.html", HTTP_GET, monitor_html_handler},
        {"/ota.html", HTTP_GET, ota_html_handler},
        {"/logs.html", HTTP_GET, logs_html_handler},
        {"/network.html", HTTP_GET, network_html_handler},

        // CSS files
        {"/css/style.css", HTTP_GET, css_style_handler},

        // JS files
        {"/js/api.js", HTTP_GET, js_api_handler},
        {"/js/utils.js", HTTP_GET, js_utils_handler},
        {"/js/app.js", HTTP_GET, js_app_handler},
        {"/js/config.js", HTTP_GET, js_config_handler},
        {"/js/monitor.js", HTTP_GET, js_monitor_handler},
        {"/js/ota.js", HTTP_GET, js_ota_handler},
        {"/js/logs.js", HTTP_GET, js_logs_handler},
        {"/js/network.js", HTTP_GET, js_network_handler},

        // Configuration endpoints
        {"/api/config/wifi", HTTP_GET, api_get_wifi_handler},
        {"/api/config/wifi", HTTP_POST, api_post_wifi_handler},
        {"/api/config/tcp", HTTP_GET, api_get_tcp_handler},
        {"/api/config/tcp", HTTP_POST, api_post_tcp_handler},
        {"/api/config/audio", HTTP_GET, api_get_audio_handler},
        {"/api/config/audio", HTTP_POST, api_post_audio_handler},
        {"/api/config/buffer", HTTP_GET, api_get_buffer_handler},
        {"/api/config/buffer", HTTP_POST, api_post_buffer_handler},
        {"/api/config/tasks", HTTP_GET, api_get_tasks_handler},
        {"/api/config/tasks", HTTP_POST, api_post_tasks_handler},
        {"/api/config/error", HTTP_GET, api_get_error_handler},
        {"/api/config/error", HTTP_POST, api_post_error_handler},
        {"/api/config/debug", HTTP_GET, api_get_debug_handler},
        {"/api/config/debug", HTTP_POST, api_post_debug_handler},
        {"/api/config/all", HTTP_GET, api_get_all_config_handler},

        // System endpoints
        {"/api/system/status", HTTP_GET, api_get_status_handler},
        {"/api/system/info", HTTP_GET, api_get_info_handler},
        {"/api/system/restart", HTTP_POST, api_post_restart_handler},
        {"/api/system/factory-reset", HTTP_POST, api_post_factory_reset_handler},
        {"/api/system/save", HTTP_POST, api_post_save_config_handler},
        {"/api/system/load", HTTP_POST, api_post_load_config_handler},
        {"/api/system/backup", HTTP_GET, api_get_backup_handler},
        {"/api/system/restore", HTTP_POST, api_post_restore_handler},
        {"/api/system/validate", HTTP_GET, api_get_validate_handler},

        // Performance monitoring endpoints
        {"/api/performance/metrics", HTTP_GET, api_get_performance_metrics_handler},

        // Remote monitoring endpoints
        {"/api/monitoring/history", HTTP_GET, api_get_monitoring_history_handler},
        {"/api/monitoring/alerts", HTTP_GET, api_get_monitoring_alerts_handler},
        {"/api/monitoring/alerts", HTTP_DELETE, api_delete_monitoring_alerts_handler},
        {"/api/monitoring/summary", HTTP_GET, api_get_monitoring_summary_handler},
        {"/api/monitoring/config", HTTP_POST, api_post_monitoring_config_handler}};

    // Register all endpoints with the refactored helper
    register_endpoints(server, endpoints, sizeof(endpoints) / sizeof(endpoints[0]));

    // Register OTA endpoints (these handle their own auth and CORS)
    ota_handler_register_endpoints(server);

    // Register OPTIONS handler for CORS preflight on all API endpoints
    httpd_uri_t options_uri = {
        .uri = "/api/*",
        .method = HTTP_OPTIONS,
        .handler = options_handler,
        .user_ctx = NULL,
        .is_websocket = false,
        .handle_ws_control_frames = false,
        .supported_subprotocol = NULL};
    httpd_register_uri_handler(server, &options_uri);

    // Register 404 handler (must be last)
    httpd_register_err_handler(server, HTTPD_404_NOT_FOUND, notfound_handler);

    ESP_LOGI(TAG, "Web server started successfully with %zu endpoints", sizeof(endpoints) / sizeof(endpoints[0]));
    return true;
}

bool web_server_is_running(void)
{
    return (server != NULL);
}

void web_server_deinit(void)
{
    if (server != NULL)
    {
        httpd_stop(server);
        server = NULL;
        ESP_LOGI(TAG, "Web server stopped");
    }
}

httpd_handle_t web_server_get_handle(void)
{
    return server;
}